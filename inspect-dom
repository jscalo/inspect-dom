#!/usr/bin/env node

const CDP = require('chrome-remote-interface');
const { execSync } = require('child_process');

async function getFrontTabURL() {
    const script = `const chrome = Application("Google Chrome");
    chrome.windows[0].activeTab().url();`;
    return execSync(`osascript -l JavaScript -e "${script.replace(/"/g, '\\"')}"`).toString().trim();
}

async function findCorrectTab(targetUrl, debug = false) {
    // List all available tabs
    const response = await fetch('http://localhost:9222/json');
    const tabs = await response.json();
    
    if (debug) {
        console.log('Available tabs:');
        tabs.forEach((tab, i) => {
            console.log(`  ${i}: ${tab.title} - ${tab.url}`);
        });
    }
    
    // Find tab that matches the URL from the front tab
    const matchingTab = tabs.find(tab => tab.url === targetUrl && tab.type === 'page');
    
    if (!matchingTab) {
        throw new Error(`Could not find tab with URL: ${targetUrl}`);
    }
    
    if (debug) {
        console.log(`Using tab: ${matchingTab.title} - ${matchingTab.url}`);
    }
    
    return matchingTab;
}

function usage() {
    console.log(`inspect-dom - Inspect DOM elements and their styles from Chrome

USAGE:
    inspect-dom <selector> [options]

ARGUMENTS:
    <selector>          CSS selector for the element to inspect (e.g., "#myId", ".myClass", "div.container")

OPTIONS:
    -r, --recursive         Include child elements (default: only show matching element)
    --styles                Show declared CSS styles for each element
    --computed-styles       Show computed CSS styles for each element
    --show-implicit-styles  Include browser-computed and implicit CSS properties (default: explicit styles only)
    --debug                 Show verbose debugging information (for troubleshooting only)
    -h, --help              Show this help message

DESCRIPTION:
    Connects to Chrome's remote debugging interface to inspect DOM elements and their styles.
    Chrome must be launched with remote debugging enabled:
    
    /Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --remote-debugging-port=9222

    By default, the tool will inspect only the element matching the selector. Use -r to 
    include child elements. When style options are provided, it will show the CSS styles 
    for the selected element(s).

EXAMPLES:
    inspect-dom #header
        Show only the element with id "header"
        
    inspect-dom .sidebar -r
        Show element with class "sidebar" and all its children
        
    inspect-dom div.main-content --styles
        Show element and its inline styles (no children)
        
    inspect-dom .container -r --computed-styles
        Show element and all children with computed styles
        
    inspect-dom .nav -r --styles --computed-styles
        Show element and children with both inline and computed styles
        
    inspect-dom .container --styles --show-implicit-styles
        Show element styles including browser-computed properties
        
    inspect-dom "div .container" --styles
        Show descendant selector
        
    inspect-dom "input[type='text']" --styles
        Show attribute selector`);
    process.exit(0);
}

const [, , selector, ...flags] = process.argv;

// Check for help flags first
if (flags.includes('-h') || flags.includes('--help') || selector === '-h' || selector === '--help') {
    usage();
}

if (!selector) usage();

const recursive = flags.includes('-r') || flags.includes('--recursive');
const showDeclared = flags.includes('--styles');
const showComputed = flags.includes('--computed-styles');
const showImplicit = flags.includes('--show-implicit-styles');
const debug = flags.includes('--debug');

// Validate flags - check for unsupported options
const validFlags = ['-r', '--recursive', '--styles', '--computed-styles', '--show-implicit-styles', '--debug', '-h', '--help'];
const invalidFlags = flags.filter(flag => !validFlags.includes(flag));
if (invalidFlags.length > 0) {
    console.error(`Error: Unsupported option(s): ${invalidFlags.join(', ')}\n`);
    console.log(`inspect-dom - Inspect DOM elements and their styles from Chrome

USAGE:
    inspect-dom <selector> [options]

ARGUMENTS:
    <selector>          CSS selector for the element to inspect (e.g., "#myId", ".myClass", "div.container")

OPTIONS:
    -r, --recursive         Include child elements (default: only show matching element)
    --styles                Show declared CSS styles for each element
    --computed-styles       Show computed CSS styles for each element
    --show-implicit-styles  Include browser-computed and implicit CSS properties (default: explicit styles only)
    --debug                 Show verbose debugging information (for troubleshooting only)
    -h, --help              Show this help message

Use -h or --help for more information.`);
    process.exit(1);
}

// Calculate CSS specificity for sorting
function calculateSpecificity(selectorText) {
    // Simple specificity calculation: count IDs, classes, and elements
    const ids = (selectorText.match(/#[a-zA-Z0-9_-]+/g) || []).length;
    const classes = (selectorText.match(/\.[a-zA-Z0-9_-]+/g) || []).length;
    const attributes = (selectorText.match(/\[[^\]]+\]/g) || []).length;
    const pseudoClasses = (selectorText.match(/:[a-zA-Z-]+(?:\([^)]*\))?/g) || []).length;
    const elements = (selectorText.match(/^[a-zA-Z][a-zA-Z0-9-]*|(?:^|\s)[a-zA-Z][a-zA-Z0-9-]*/g) || []).length;
    
    // Return specificity as [a, b, c] where a=IDs, b=classes+attributes+pseudo-classes, c=elements
    return [ids, classes + attributes + pseudoClasses, elements];
}

// Compare specificity values
function compareSpecificity(a, b) {
    for (let i = 0; i < 3; i++) {
        if (a[i] !== b[i]) {
            return b[i] - a[i]; // Higher specificity first
        }
    }
    return 0;
}

// Filter out CSS properties that are implicit (browser-computed) when --no-defaults is used
function filterImplicitProperties(properties, debug = false) {
    return properties.filter(prop => {
        if (debug) {
            console.log(`        DEBUG: ${prop.name}: ${prop.value} (implicit: ${prop.implicit})`);
        }
        
        // If implicit flag is unavailable, fall back to value-based filtering for common defaults
        if (prop.implicit === undefined) {
            const defaultValues = ['initial', 'unset'];
            const isDefaultValue = defaultValues.includes(prop.value.toLowerCase().trim());
            if (debug && isDefaultValue) {
                console.log(`        DEBUG: Filtering ${prop.name} due to default value (implicit flag unavailable)`);
            }
            return !isDefaultValue;
        }
        
        // Keep properties that are explicitly declared (not implicit browser defaults)
        return prop.implicit !== true;
    });
}

// Cache for stylesheet information to avoid repeated API calls
const stylesheetCache = new Map();

// Try to map a styleSheetId to an actual filename using heuristics
async function tryMapStylesheetId(styleSheetId, client, debug = false) {
    try {
        // Check if we have cached stylesheet resources
        const stylesheetResources = client._stylesheetResources;
        if (!stylesheetResources || stylesheetResources.length === 0) {
            return null;
        }
        
        // Extract the last number from styleSheetId (e.g., "style-sheet-22624-29" -> 29)
        const match = styleSheetId.match(/style-sheet-\d+-(\d+)$/);
        if (!match) {
            return null;
        }
        
        const sheetIndex = parseInt(match[1]);
        
        // Filter to only local stylesheets (not external ones like Google Fonts)
        const localStylesheets = stylesheetResources.filter(url => 
            !url.includes('googleapis.com') && 
            !url.includes('fonts.gstatic.com') &&
            !url.includes('cdnjs.cloudflare.com') &&
            !url.includes('unpkg.com')
        );
        
        if (debug) {
            console.log(`    Trying to map sheet index ${sheetIndex} to local stylesheets:`, localStylesheets);
        }
        
        // Simple mapping: if we have local stylesheets, map by index
        if (localStylesheets.length > 0) {
            // For now, assume the first local stylesheet is likely the main one
            // This is a heuristic that works for simple cases
            const mappedUrl = localStylesheets[0];
            
            if (debug) {
                console.log(`    Mapped styleSheetId ${styleSheetId} (index ${sheetIndex}) to: ${mappedUrl}`);
            }
            
            return mappedUrl;
        }
        
        return null;
        
    } catch (error) {
        if (debug) {
            console.log(`    Error mapping stylesheet ID: ${error.message}`);
        }
        return null;
    }
}

// Collect all stylesheet information during initialization
async function collectStylesheetInfo(CSS) {
    try {
        // Try to get all stylesheet headers using CSS.getAllStyleSheets if available
        // This might provide the sourceURL information we need
        
        try {
            // Note: CSS.getAllStyleSheets might not be available in all Chrome versions
            // but it's worth trying as it could provide sourceURL information
            const allStyleSheets = await CSS.getAllStyleSheets();
            
            if (debug) {
                console.log(`Found ${allStyleSheets.headers ? allStyleSheets.headers.length : 0} stylesheet headers`);
            }
            
            // Cache stylesheet headers if available
            if (allStyleSheets.headers) {
                for (const header of allStyleSheets.headers) {
                    const info = {
                        url: header.sourceURL || 'unknown',
                        origin: header.origin || 'regular',
                        title: header.title || '',
                        disabled: header.disabled || false
                    };
                    
                    stylesheetCache.set(header.styleSheetId, info);
                    
                    if (debug) {
                        console.log(`    Cached stylesheet header ${header.styleSheetId}: ${info.url}`);
                    }
                }
            }
            
        } catch (getAllError) {
            if (debug) {
                console.log(`CSS.getAllStyleSheets not available or failed: ${getAllError.message}`);
            }
            // This is expected in many Chrome versions - continue without it
        }
        
        if (debug) {
            console.log('Stylesheet collection initialized - will collect info on-demand');
        }
        
    } catch (error) {
        if (debug) {
            console.log(`Warning: Could not initialize stylesheet collection: ${error.message}`);
        }
        // Continue without caching - we'll fall back to the old method
    }
}

// Get stylesheet information with caching and improved source URL detection
async function getStylesheetInfo(styleSheetId, CSS) {
    if (!styleSheetId) {
        return { url: 'inline', origin: 'inline' };
    }
    
    // Check cache first
    if (stylesheetCache.has(styleSheetId)) {
        return stylesheetCache.get(styleSheetId);
    }
    
    try {
        // The key insight: CSS.getMatchedStylesForNode should have already provided
        // the stylesheet headers with sourceURL information. However, we might need
        // to access this differently. Let's try a direct approach to get stylesheet
        // headers if the CDP supports it.
        
        let filename = 'unknown';
        let origin = 'regular';
        let sourceURL = null;
        
        // Try to get stylesheet text - this might give us more info in some cases
        try {
            const styleSheetInfo = await CSS.getStyleSheetText({ styleSheetId });
            // Unfortunately, getStyleSheetText typically only returns the text content
            // The sourceURL would come from the original getMatchedStylesForNode response
        } catch (textError) {
            if (debug) {
                console.log(`Could not get stylesheet text for ${styleSheetId}: ${textError.message}`);
            }
        }
        
        // The styleSheetId often contains clues about the source
        if (styleSheetId.includes('inspector')) {
            filename = 'inspector-styles';
            origin = 'inspector';
        } else if (styleSheetId.includes('user-agent')) {
            filename = 'user-agent-styles';
            origin = 'user-agent';
        } else {
            // For regular stylesheets, we'll show a simplified ID
            // The actual source URL should come from the matchedCSSRules response
            filename = `stylesheet-${styleSheetId.split('-').pop()}`;
            origin = 'regular';
        }
        
        const info = { url: filename, origin, sourceURL };
        stylesheetCache.set(styleSheetId, info);
        return info;
        
    } catch (error) {
        // Fallback: try to get some info from the stylesheet ID itself
        let filename = 'unknown';
        let origin = 'regular';
        
        if (styleSheetId.includes('inspector')) {
            filename = 'inspector-styles';
            origin = 'inspector';
        } else if (styleSheetId.includes('user-agent')) {
            filename = 'user-agent-styles';
            origin = 'user-agent';
        } else {
            filename = `stylesheet-${styleSheetId.split('-').pop()}`;
            origin = 'regular';
        }
        
        const info = { url: filename, origin };
        stylesheetCache.set(styleSheetId, info);
        return info;
    }
}

// Helper function to extract filename from URL
function extractFilenameFromUrl(url) {
    if (!url || url === 'unknown' || url === 'inline') {
        return url;
    }
    
    try {
        // Handle data URLs
        if (url.startsWith('data:')) {
            return 'data-url-styles';
        }
        
        // Handle blob URLs
        if (url.startsWith('blob:')) {
            return 'blob-styles';
        }
        
        // Extract filename from regular URLs
        const urlParts = url.split('/');
        const filename = urlParts[urlParts.length - 1];
        
        // Remove query parameters and fragments
        const cleanFilename = filename.split('?')[0].split('#')[0];
        
        // If no filename (ends with /), show domain
        if (!cleanFilename) {
            const urlObj = new URL(url);
            return urlObj.hostname || 'external-styles';
        }
        
        return cleanFilename || 'stylesheet';
        
    } catch (error) {
        // If URL parsing fails, return the original or a fallback
        return url.length > 50 ? 'external-styles' : url;
    }
}

// Enhanced function to get readable stylesheet source name with line numbers
async function getStylesheetDisplayName(rule, CSS) {
    if (rule.origin === 'user-agent') {
        return 'user-agent stylesheet';
    } else if (rule.origin === 'inspector') {
        return 'inspector stylesheet';
    } else if (rule.origin === 'injected') {
        return 'injected stylesheet';
    } else if (!rule.styleSheetId) {
        return 'inline styles';
    } else {
        try {
            // Get the actual stylesheet information using the styleSheetId
            // The rule should contain source range information
            let displayName = '';
            
            // Try to get stylesheet headers to find the sourceURL
            const styleInfo = await getStylesheetInfo(rule.styleSheetId, CSS);
            
            // Check if the rule has source range information (line numbers)
            if (rule.style && rule.style.range) {
                const lineNumber = rule.style.range.startLine + 1; // Convert from 0-based to 1-based
                
                // If we have a source URL, extract the filename
                if (styleInfo.url && styleInfo.url !== 'unknown' && styleInfo.url !== 'inline') {
                    const filename = extractFilenameFromUrl(styleInfo.url);
                    displayName = `${filename}:${lineNumber}`;
                } else {
                    // Fallback with line number
                    const id = rule.styleSheetId;
                    if (id.includes('style-sheet')) {
                        const match = id.match(/style-sheet-(\d+)-(\d+)/);
                        if (match) {
                            displayName = `stylesheet-${match[2]}:${lineNumber}`;
                        } else {
                            displayName = `stylesheet-${id.split('-').pop()}:${lineNumber}`;
                        }
                    } else {
                        displayName = `stylesheet-${id.split('-').pop()}:${lineNumber}`;
                    }
                }
            } else {
                // No line number available, just show filename
                if (styleInfo.url && styleInfo.url !== 'unknown' && styleInfo.url !== 'inline') {
                    displayName = extractFilenameFromUrl(styleInfo.url);
                } else {
                    // Final fallback
                    const id = rule.styleSheetId;
                    if (id.includes('style-sheet')) {
                        const match = id.match(/style-sheet-(\d+)-(\d+)/);
                        if (match) {
                            displayName = `stylesheet-${match[2]}`;
                        } else {
                            displayName = `stylesheet-${id.split('-').pop()}`;
                        }
                    } else {
                        displayName = `stylesheet-${id.split('-').pop()}`;
                    }
                }
            }
            
            return displayName;
            
        } catch (error) {
            if (debug) {
                console.log(`Error getting stylesheet display name: ${error.message}`);
            }
            // Ultimate fallback
            const id = rule.styleSheetId;
            return `stylesheet-${id.split('-').pop()}`;
        }
    }
}

// Helper function to deduplicate CSS properties and keep only winning values
function deduplicateProperties(cssProperties) {
    const propertyMap = new Map();
    
    // Process properties in order, later ones override earlier ones
    for (const prop of cssProperties) {
        if (prop.name && prop.value) {
            propertyMap.set(prop.name, prop.value);
        }
    }
    
    return Array.from(propertyMap.entries()).map(([name, value]) => ({ name, value }));
}

// Helper function to deduplicate rules by selector text
function deduplicateRules(rules) {
    const ruleMap = new Map();
    
    for (const ruleMatch of rules) {
        const selectorText = ruleMatch.rule.selectorList.text;
        if (!ruleMap.has(selectorText)) {
            ruleMap.set(selectorText, ruleMatch);
        }
    }
    
    return Array.from(ruleMap.values());
}

// Main function to display styled output like Chrome DevTools
async function displayStyledOutput(styleInfo, CSS, debug, baseIndent = "") {
    console.log(`${baseIndent}  Styles:`);
    
    // 1. Show inline styles (highest priority)
    if (styleInfo.inlineStyle && styleInfo.inlineStyle.cssText) {
        console.log(`${baseIndent}    Inline Styles:`);
        console.log(`${baseIndent}      style="${styleInfo.inlineStyle.cssText}"`);
        let uniqueProps = deduplicateProperties(styleInfo.inlineStyle.cssProperties);
        if (!showImplicit) {
            uniqueProps = filterImplicitProperties(uniqueProps, debug);
        }
        for (const prop of uniqueProps) {
            console.log(`${baseIndent}        ${prop.name}: ${prop.value}`);
        }
    }
    
    if (styleInfo.attributesStyle && styleInfo.attributesStyle.cssProperties.length > 0) {
        console.log(`${baseIndent}    Attribute Styles:`);
        let uniqueProps = deduplicateProperties(styleInfo.attributesStyle.cssProperties);
        if (!showImplicit) {
            uniqueProps = filterImplicitProperties(uniqueProps, debug);
        }
        for (const prop of uniqueProps) {
            console.log(`${baseIndent}        ${prop.name}: ${prop.value}`);
        }
    }
    
    // 2. Show stylesheet styles (sorted by specificity)
    if (styleInfo.matchedCSSRules && styleInfo.matchedCSSRules.length > 0) {
        console.log(`${baseIndent}    Stylesheet Styles:`);
        
        // Filter out user-agent styles unless --show-implicit-styles is set
        let rulesToShow = styleInfo.matchedCSSRules;
        if (!showImplicit) {
            rulesToShow = styleInfo.matchedCSSRules.filter(ruleMatch => 
                ruleMatch.rule.origin !== 'user-agent'
            );
        }
        
        // Deduplicate rules by selector
        rulesToShow = deduplicateRules(rulesToShow);
        
        // Sort by specificity (highest first)
        rulesToShow.sort((a, b) => {
            const specA = calculateSpecificity(a.rule.selectorList.text);
            const specB = calculateSpecificity(b.rule.selectorList.text);
            return compareSpecificity(specA, specB);
        });
        
        for (const ruleMatch of rulesToShow) {
            const rule = ruleMatch.rule;
            if (rule.selectorList && rule.style && rule.style.cssProperties.length > 0) {
                const stylesheetName = await getStylesheetDisplayName(rule, CSS);
                console.log(`${baseIndent}      ${rule.selectorList.text} - ${stylesheetName}:`);
                let uniqueProps = deduplicateProperties(rule.style.cssProperties);
                if (!showImplicit) {
                    uniqueProps = filterImplicitProperties(uniqueProps, debug);
                }
                for (const prop of uniqueProps) {
                    console.log(`${baseIndent}        ${prop.name}: ${prop.value}`);
                }
            }
        }
    }
    
    // 3. Show inherited styles
    if (styleInfo.inherited && styleInfo.inherited.length > 0) {
        console.log(`${baseIndent}    Inherited Styles:`);
        
        // Track unique ancestor rules to avoid showing duplicates across levels
        const seenRules = new Set();
        
        for (let i = 0; i < styleInfo.inherited.length; i++) {
            const inheritedEntry = styleInfo.inherited[i];
            const level = i + 1;
            let hasAnyStyles = false;
            
            // Check if this level has any unique styles before showing the header
            let uniqueInlineProps = [];
            if (inheritedEntry.inlineStyle && inheritedEntry.inlineStyle.cssProperties.length > 0) {
                uniqueInlineProps = deduplicateProperties(inheritedEntry.inlineStyle.cssProperties);
                if (uniqueInlineProps.length > 0) {
                    hasAnyStyles = true;
                }
            }
            
            let uniqueRules = [];
            if (inheritedEntry.matchedCSSRules) {
                let ancestorRules = inheritedEntry.matchedCSSRules;
                if (!showImplicit) {
                    ancestorRules = ancestorRules.filter(ruleMatch => 
                        ruleMatch.rule.origin !== 'user-agent'
                    );
                }
                
                // Filter out rules we've already seen
                uniqueRules = ancestorRules.filter(ruleMatch => {
                    const ruleKey = ruleMatch.rule.selectorList.text + '|' + 
                                   ruleMatch.rule.style.cssProperties.map(p => `${p.name}:${p.value}`).join(';');
                    if (seenRules.has(ruleKey)) {
                        return false;
                    }
                    seenRules.add(ruleKey);
                    return true;
                });
                
                if (uniqueRules.length > 0) {
                    hasAnyStyles = true;
                }
            }
            
            // Only show this level if it has unique styles
            if (hasAnyStyles) {
                console.log(`${baseIndent}      From ancestor level ${level}:`);
                
                if (uniqueInlineProps.length > 0) {
                    console.log(`${baseIndent}        Inline styles:`);
                    let propsToShow = uniqueInlineProps;
                    if (!showImplicit) {
                        propsToShow = filterImplicitProperties(uniqueInlineProps, debug);
                    }
                    for (const prop of propsToShow) {
                        console.log(`${baseIndent}          ${prop.name}: ${prop.value}`);
                    }
                }
                
                for (const ruleMatch of uniqueRules) {
                    const rule = ruleMatch.rule;
                    if (rule.selectorList && rule.style && rule.style.cssProperties.length > 0) {
                        console.log(`${baseIndent}        ${rule.selectorList.text}:`);
                        let uniqueProps = deduplicateProperties(rule.style.cssProperties);
                        if (!showImplicit) {
                            uniqueProps = filterImplicitProperties(uniqueProps, debug);
                        }
                        for (const prop of uniqueProps) {
                            console.log(`${baseIndent}          ${prop.name}: ${prop.value}`);
                        }
                    }
                }
            }
        }
    }
}

(async function() {
    try {
        const url = await getFrontTabURL();
        const correctTab = await findCorrectTab(url, debug);
        
        // Connect using the tab's webSocketDebuggerUrl
        const client = await CDP({
            target: correctTab.webSocketDebuggerUrl
        });
        const { DOM, CSS, Runtime, Page } = client;

        if (debug) console.log(`Connecting to URL: ${url}`);
        
        await Page.enable();
        await Runtime.enable();
        await DOM.enable();
        if (showDeclared || showComputed) {
            await CSS.enable();
            // Collect stylesheet information for better filename display
            await collectStylesheetInfo(CSS);
            
            // Try to get page resources to map stylesheet IDs to actual filenames
            try {
                const { frameTree } = await Page.getFrameTree();
                if (debug) {
                    console.log('Got page frame tree for resource mapping');
                }
                
                // Try to get resources for the main frame
                const resources = await Page.getResourceTree();
                if (resources && resources.frameTree && resources.frameTree.resources) {
                    if (debug) {
                        console.log(`Found ${resources.frameTree.resources.length} page resources`);
                        for (const resource of resources.frameTree.resources) {
                            if (resource.type === 'Stylesheet') {
                                console.log(`  Stylesheet resource: ${resource.url}`);
                            }
                        }
                    }
                    
                    // Cache stylesheet resources by URL for later lookup
                    const stylesheetResources = [];
                    for (const resource of resources.frameTree.resources) {
                        if (resource.type === 'Stylesheet') {
                            stylesheetResources.push(resource.url);
                        }
                    }
                    
                    // Store the stylesheet resources for later use
                    // We'll try to match them to styleSheetIds using heuristics
                    if (stylesheetResources.length > 0) {
                        client._stylesheetResources = stylesheetResources;
                        if (debug) {
                            console.log(`Cached ${stylesheetResources.length} stylesheet resources for matching`);
                        }
                    }
                }
            } catch (resourceError) {
                if (debug) {
                    console.log(`Could not get page resources: ${resourceError.message}`);
                }
            }
        }
        
        // Make sure DOM is fully loaded and get the document
        // Always use pierce: true to traverse shadow DOM boundaries
        const { root } = await DOM.getDocument({ 
            depth: -1, 
            pierce: true 
        });

        // No need to navigate since we're already on the front tab
        
        // Test if we can access the document
        if (debug) {
            const { result: testResult } = await Runtime.evaluate({
                expression: `document.title`,
                returnByValue: true
            });
            console.log(`Page title: ${testResult.value}`);
            console.log(`Looking for selector: ${selector}`);
        }

    // Evaluate selector and collect elements based on recursive flag
    const { result } = await Runtime.evaluate({
        expression: `
      (function() {
        const recursive = ${recursive};
        
        // Shadow DOM-aware element finding - always traverse shadow DOM
        function findElementInShadowDOM(selector, context = document) {
          // First try normal query
          let element = context.querySelector(selector);
          if (element) return element;
          
          // Always search within shadow roots
          const elementsWithShadow = context.querySelectorAll('*');
          for (const el of elementsWithShadow) {
            if (el.shadowRoot) {
              element = findElementInShadowDOM(selector, el.shadowRoot);
              if (element) return element;
            }
          }
          
          return null;
        }
        
        const root = findElementInShadowDOM('${selector}');
        if (!root) return null;
        
        function walk(node, depth = 0, inShadowRoot = false) {
          const nodeInfo = {
            tag: node.tagName,
            id: node.id,
            class: node.className,
            attributes: {},
            shadowContext: inShadowRoot
          };
          
          // Collect relevant attributes
          const relevantAttrs = ['src', 'alt', 'href', 'title', 'type', 'value', 'placeholder', 'data-*'];
          for (let i = 0; i < node.attributes.length; i++) {
            const attr = node.attributes[i];
            // Include common attributes or data attributes
            if (['src', 'alt', 'href', 'title', 'type', 'value', 'placeholder'].includes(attr.name) || 
                attr.name.startsWith('data-')) {
              nodeInfo.attributes[attr.name] = attr.value;
            }
          }
          
          if (recursive) {
            nodeInfo.children = [];
            
            // Add regular children
            if (node.children.length > 0) {
              Array.from(node.children).forEach(child => {
                nodeInfo.children.push(walk(child, depth + 1, inShadowRoot));
              });
            }
            
            // Add shadow DOM children - always traverse when they exist
            if (node.shadowRoot) {
              nodeInfo.hasShadowRoot = true;
              Array.from(node.shadowRoot.children).forEach(child => {
                nodeInfo.children.push(walk(child, depth + 1, true));
              });
            }
          }
          
          return nodeInfo;
        }
        
        const tree = walk(root);
        return JSON.stringify({ tree });
      })()
    `,
        returnByValue: true
    });

    if (!result.value) {
        console.error(`Element not found: ${selector}`);
        process.exit(1);
    }

    const { tree } = JSON.parse(result.value);
    
    // Display the DOM tree structure in HTML-like format
    function displayTree(node, depth = 0) {
        const indent = "  ".repeat(depth);
        const tag = node.tag.toLowerCase();
        
        // Build attributes string for HTML-like display
        let attrs = "";
        if (node.id) {
            attrs += ` id="${node.id}"`;
        }
        if (node.class && node.class.trim()) {
            attrs += ` class="${node.class.trim()}"`;
        }
        
        // Add other relevant attributes
        if (node.attributes) {
            for (const [attrName, attrValue] of Object.entries(node.attributes)) {
                if (attrName !== 'id' && attrName !== 'class') {
                    // Truncate very long attribute values for readability
                    const displayValue = attrValue.length > 50 ? attrValue.substring(0, 50) + "..." : attrValue;
                    attrs += ` ${attrName}="${displayValue}"`;
                }
            }
        }
        
        // Add shadow DOM context indicator
        let shadowIndicator = "";
        if (node.shadowContext) {
            shadowIndicator = " [shadow]";
        }
        if (node.hasShadowRoot) {
            shadowIndicator += " [has-shadow-root]";
        }
        
        // Display in HTML-like format
        if (node.children && node.children.length > 0) {
            console.log(`${indent}<${tag}${attrs}>${shadowIndicator}`);
            node.children.forEach(child => displayTree(child, depth + 1));
            console.log(`${indent}</${tag}>`);
        } else {
            // Self-closing or empty element
            const selfClosingTags = ['img', 'input', 'br', 'hr', 'meta', 'link', 'area', 'base', 'col', 'embed', 'source', 'track', 'wbr'];
            if (selfClosingTags.includes(tag)) {
                console.log(`${indent}<${tag}${attrs} />${shadowIndicator}`);
            } else {
                console.log(`${indent}<${tag}${attrs}></${tag}>${shadowIndicator}`);
            }
        }
    }
    
    console.log("--- DOM Structure ---\n");
    displayTree(tree);

    if (showDeclared || showComputed) {
        console.log("\n--- Style Information ---\n");
        
        // Get all DOM elements we need to process
        const { result: elementsResult } = await Runtime.evaluate({
            expression: `
                (function() {
                    const recursive = ${recursive};
                    
                    // Shadow DOM-aware element finding - always traverse shadow DOM
                    function findElementInShadowDOM(selector, context = document) {
                        // First try normal query
                        let element = context.querySelector(selector);
                        if (element) return element;
                        
                        // Always search within shadow roots
                        const elementsWithShadow = context.querySelectorAll('*');
                        for (const el of elementsWithShadow) {
                            if (el.shadowRoot) {
                                element = findElementInShadowDOM(selector, el.shadowRoot);
                                if (element) return element;
                            }
                        }
                        
                        return null;
                    }
                    
                    const root = findElementInShadowDOM('${selector}');
                    if (!root) return null;
                    
                    const results = [];
                    
                    function processElement(node, depth = 0, path = []) {
                        // Generate a unique selector for this element
                        let elementSelector = node.tagName.toLowerCase();
                        if (node.id) {
                            elementSelector = '#' + node.id;
                        } else if (node.className) {
                            const classes = node.className.trim().split(/\s+/).join('.');
                            elementSelector = node.tagName.toLowerCase() + '.' + classes;
                        } else {
                            // Use nth-child selector for elements without id/class
                            const parent = node.parentElement;
                            if (parent) {
                                const siblings = Array.from(parent.children).filter(child => 
                                    child.tagName === node.tagName
                                );
                                const index = siblings.indexOf(node) + 1;
                                elementSelector = node.tagName.toLowerCase() + ':nth-of-type(' + index + ')';
                            }
                        }
                        
                        // Collect attributes for HTML-like display
                        const attributes = {};
                        for (let i = 0; i < node.attributes.length; i++) {
                            const attr = node.attributes[i];
                            if (['src', 'alt', 'href', 'title', 'type', 'value', 'placeholder'].includes(attr.name) || 
                                attr.name.startsWith('data-')) {
                                attributes[attr.name] = attr.value;
                            }
                        }
                        
                        results.push({
                            tag: node.tagName,
                            id: node.id,
                            class: node.className, 
                            depth: depth,
                            selector: elementSelector,
                            attributes: attributes
                        });
                        
                        // Process children only if recursive flag is set
                        if (recursive) {
                            Array.from(node.children).forEach((child, index) => 
                                processElement(child, depth + 1, [...path, index])
                            );
                        }
                    }
                    
                    processElement(root);
                    return results;
                })()
            `,
            returnByValue: true
        });

        if (!elementsResult.value) {
            console.log("No style information available");
            return;
        }

        // Process style information for all elements (recursive if enabled)
        const elementsToProcess = recursive ? elementsResult.value : [elementsResult.value[0]];
        
        for (const elementInfo of elementsToProcess) {
            try {
                // Find the DOM node for this element using its selector
                let nodeId;
                try {
                    if (elementInfo.id) {
                        // Use ID selector for elements with IDs
                        const result = await DOM.querySelector({
                            nodeId: root.nodeId,
                            selector: `#${elementInfo.id}`,
                            pierce: true
                        });
                        nodeId = result.nodeId;
                    } else if (elementInfo.selector) {
                        // Use the generated selector
                        const result = await DOM.querySelector({
                            nodeId: root.nodeId,
                            selector: elementInfo.selector,
                            pierce: true
                        });
                        nodeId = result.nodeId;
                    } else {
                        // Fallback to original selector for root element
                        const result = await DOM.querySelector({
                            nodeId: root.nodeId,
                            selector: selector,
                            pierce: true
                        });
                        nodeId = result.nodeId;
                    }
                } catch (selectorError) {
                    if (debug) {
                        console.log(`    Could not find element with selector "${elementInfo.selector}": ${selectorError.message}`);
                    }
                    continue; // Skip this element if we can't find it
                }
                
                if (debug) {
                    console.log(`    Found element with DOM node ID: ${nodeId} (selector: ${elementInfo.selector})`);
                }
                
                // Create HTML-like element description for display
                const tag = elementInfo.tag.toLowerCase();
                let attrs = "";
                if (elementInfo.id) {
                    attrs += ` id="${elementInfo.id}"`;
                }
                if (elementInfo.class && elementInfo.class.trim()) {
                    attrs += ` class="${elementInfo.class.trim()}"`;
                }
                if (elementInfo.attributes) {
                    for (const [attrName, attrValue] of Object.entries(elementInfo.attributes)) {
                        if (attrName !== 'id' && attrName !== 'class') {
                            const displayValue = attrValue.length > 30 ? attrValue.substring(0, 30) + "..." : attrValue;
                            attrs += ` ${attrName}="${displayValue}"`;
                        }
                    }
                }
                
                const indent = "  ".repeat(elementInfo.depth || 0);
                console.log(`\n${indent}<${tag}${attrs}>:`);

                if (showDeclared) {
                    try {
                    if (debug) {
                        console.log(`    Getting complete style information for DOM node ID: ${nodeId}`);
                    }
                    
                    // Get comprehensive style information
                    const styleInfo = await CSS.getMatchedStylesForNode({ nodeId: nodeId });
                    
                    // Cache stylesheet source information from the response
                    if (styleInfo.matchedCSSRules) {
                        for (const ruleMatch of styleInfo.matchedCSSRules) {
                            const rule = ruleMatch.rule;
                            if (rule.styleSheetId && rule.sourceURL) {
                                // Cache the actual source URL from the response
                                const info = {
                                    url: rule.sourceURL,
                                    origin: rule.origin || 'regular'
                                };
                                stylesheetCache.set(rule.styleSheetId, info);
                                
                                if (debug) {
                                    console.log(`    Cached stylesheet ${rule.styleSheetId}: ${rule.sourceURL}`);
                                }
                            } else if (rule.styleSheetId && !stylesheetCache.has(rule.styleSheetId)) {
                                // Try to map using heuristics and available resources
                                const mappedUrl = await tryMapStylesheetId(rule.styleSheetId, client, debug);
                                if (mappedUrl) {
                                    const info = {
                                        url: mappedUrl,
                                        origin: rule.origin || 'regular'
                                    };
                                    stylesheetCache.set(rule.styleSheetId, info);
                                    
                                    if (debug) {
                                        console.log(`    Mapped stylesheet ${rule.styleSheetId} to: ${mappedUrl}`);
                                    }
                                }
                            }
                        }
                    }
                    
                    if (debug) {
                        console.log(`    Got ${styleInfo.matchedCSSRules ? styleInfo.matchedCSSRules.length : 0} CSS rules`);
                        console.log(`    Inline style: ${styleInfo.inlineStyle ? 'present' : 'none'}`);
                        console.log(`    Inherited styles: ${styleInfo.inherited ? styleInfo.inherited.length : 0} levels`);
                        
                        // Debug all rules to see what information we have
                        if (styleInfo.matchedCSSRules && styleInfo.matchedCSSRules.length > 0) {
                            console.log(`    Rule debug details:`);
                            for (let i = 0; i < Math.min(styleInfo.matchedCSSRules.length, 3); i++) {
                                const rule = styleInfo.matchedCSSRules[i].rule;
                                console.log(`      Rule ${i}:`, {
                                    styleSheetId: rule.styleSheetId,
                                    sourceURL: rule.sourceURL,
                                    origin: rule.origin,
                                    hasRange: rule.style && rule.style.range ? 'yes' : 'no',
                                    startLine: rule.style && rule.style.range ? rule.style.range.startLine : 'none',
                                    selector: rule.selectorList ? rule.selectorList.text : 'none'
                                });
                            }
                        }
                    }
                    
                    await displayStyledOutput(styleInfo, CSS, debug, indent);
                    
                } catch (error) {
                    if (debug) {
                        console.log(`    CSS Error details: ${error.message}`);
                    }
                    // Check if this might be a shadow DOM element - try JavaScript fallback
                    if (error.message.includes("Could not find node") || nodeId === 0) {
                        if (debug) {
                            console.log("    Attempting JavaScript-based CSS extraction for shadow DOM element");
                        }
                        
                        let cssResult = null;
                        try {
                            // Use JavaScript to directly extract CSS information from shadow DOM element
                            const evaluationResult = await Runtime.evaluate({
                                expression: `
                                    (function() {
                                        const showComputed = ${showComputed};
                                        
                                        // Shadow DOM-aware element finding
                                        function findElementInShadowDOM(selector, context = document) {
                                            let element = context.querySelector(selector);
                                            if (element) return element;
                                            
                                            const elementsWithShadow = context.querySelectorAll('*');
                                            for (const el of elementsWithShadow) {
                                                if (el.shadowRoot) {
                                                    element = findElementInShadowDOM(selector, el.shadowRoot);
                                                    if (element) return element;
                                                }
                                            }
                                            return null;
                                        }
                                        
                                        const targetSelector = '${selector}';
                                        const element = findElementInShadowDOM(targetSelector);
                                        if (!element) return null;
                                        
                                        const styles = {
                                            inline: {},
                                            stylesheet: {},
                                            computed: {},
                                            hasStyles: false
                                        };
                                        
                                        // Get inline styles
                                        if (element.style && element.style.cssText) {
                                            styles.inline.cssText = element.style.cssText;
                                            styles.hasStyles = true;
                                            
                                            // Parse individual inline properties
                                            const inlineProps = {};
                                            for (let i = 0; i < element.style.length; i++) {
                                                const prop = element.style[i];
                                                const value = element.style.getPropertyValue(prop);
                                                const priority = element.style.getPropertyPriority(prop);
                                                inlineProps[prop] = priority ? value + ' !' + priority : value;
                                            }
                                            styles.inline.properties = inlineProps;
                                        }
                                        
                                        // Try to get stylesheet styles by inspecting applied rules
                                        try {
                                            const computedStyle = window.getComputedStyle(element);
                                            const stylesheetRules = {};
                                            
                                            // Get all stylesheets in the document
                                            const allStylesheets = Array.from(document.styleSheets);
                                            
                                            // Also check shadow DOM stylesheets if element is in shadow DOM
                                            let currentNode = element;
                                            while (currentNode) {
                                                if (currentNode.shadowRoot) {
                                                    const shadowSheets = Array.from(currentNode.shadowRoot.styleSheets || []);
                                                    allStylesheets.push(...shadowSheets);
                                                }
                                                currentNode = currentNode.parentNode || currentNode.host;
                                            }
                                            
                                            // Check each stylesheet for rules that match this element
                                            for (const sheet of allStylesheets) {
                                                try {
                                                    const rules = Array.from(sheet.cssRules || []);
                                                    for (const rule of rules) {
                                                        if (rule.type === CSSRule.STYLE_RULE) {
                                                            try {
                                                                if (element.matches(rule.selectorText)) {
                                                                    const sheetHref = sheet.href || 'inline styles';
                                                                    const sheetName = sheetHref.includes('/') ? 
                                                                        sheetHref.split('/').pop() : sheetHref;
                                                                    
                                                                    if (!stylesheetRules[sheetName]) {
                                                                        stylesheetRules[sheetName] = {};
                                                                    }
                                                                    
                                                                    const ruleProps = {};
                                                                    for (let i = 0; i < rule.style.length; i++) {
                                                                        const prop = rule.style[i];
                                                                        const value = rule.style.getPropertyValue(prop);
                                                                        const priority = rule.style.getPropertyPriority(prop);
                                                                        ruleProps[prop] = priority ? value + ' !' + priority : value;
                                                                    }
                                                                    
                                                                    stylesheetRules[sheetName][rule.selectorText] = ruleProps;
                                                                    styles.hasStyles = true;
                                                                }
                                                            } catch (matchError) {
                                                                // Skip rules that can't be matched
                                                            }
                                                        }
                                                    }
                                                } catch (sheetError) {
                                                    // Skip stylesheets that can't be accessed (CORS, etc.)
                                                }
                                            }
                                            
                                            styles.stylesheet = stylesheetRules;
                                        } catch (stylesheetError) {
                                            // If stylesheet extraction fails, continue with computed styles only
                                        }
                                        
                                        // Get computed styles only if requested
                                        if (showComputed) {
                                            const computedStyle = window.getComputedStyle(element);
                                            const importantProps = [
                                                // Layout properties
                                                'display', 'position', 'width', 'height', 'min-width', 'min-height', 'max-width', 'max-height',
                                                'margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left',
                                                'padding', 'padding-top', 'padding-right', 'padding-bottom', 'padding-left',
                                                'border', 'border-top', 'border-right', 'border-bottom', 'border-left',
                                                'border-width', 'border-style', 'border-color', 'border-radius',
                                                // Positioning
                                                'top', 'left', 'right', 'bottom', 'z-index',
                                                // Flexbox & Grid
                                                'flex', 'flex-direction', 'flex-wrap', 'justify-content', 'align-items', 'align-content',
                                                'grid', 'grid-template-columns', 'grid-template-rows', 'grid-gap',
                                                // Background & Colors
                                                'background', 'background-color', 'background-image', 'background-position', 'background-size',
                                                'color', 'opacity', 'visibility',
                                                // Typography
                                                'font-size', 'font-family', 'font-weight', 'font-style', 'line-height', 'text-align',
                                                'text-decoration', 'text-transform', 'letter-spacing', 'word-spacing',
                                                // Other common properties
                                                'overflow', 'overflow-x', 'overflow-y', 'float', 'clear', 'cursor',
                                                'box-shadow', 'text-shadow', 'transform', 'transition', 'animation'
                                            ];
                                            
                                            for (const prop of importantProps) {
                                                const value = computedStyle.getPropertyValue(prop);
                                                // Be much less restrictive - only filter out truly empty values
                                                if (value && value.trim() !== '') {
                                                    styles.computed[prop] = value;
                                                    styles.hasStyles = true;
                                                }
                                            }
                                        }
                                        
                                        return styles;
                                    })()
                                `,
                                returnByValue: true
                            });
                            
                            cssResult = evaluationResult.result;
                            
                            if (cssResult.value && cssResult.value.hasStyles) {
                                const styles = cssResult.value;
                                console.log("  Styles (extracted from shadow DOM):");
                                
                                // Show inline styles
                                if (styles.inline.cssText) {
                                    console.log("    Inline Styles:");
                                    console.log(`      style="${styles.inline.cssText}"`);
                                    if (styles.inline.properties) {
                                        for (const [prop, value] of Object.entries(styles.inline.properties)) {
                                            console.log(`        ${prop}: ${value}`);
                                        }
                                    }
                                }
                                
                                // Show stylesheet styles
                                if (styles.stylesheet && Object.keys(styles.stylesheet).length > 0) {
                                    console.log("    Stylesheet Styles:");
                                    for (const [sheetName, rules] of Object.entries(styles.stylesheet)) {
                                        for (const [selector, properties] of Object.entries(rules)) {
                                            console.log(`      ${selector} - ${sheetName}:`);
                                            for (const [prop, value] of Object.entries(properties)) {
                                                console.log(`        ${prop}: ${value}`);
                                            }
                                        }
                                    }
                                }
                                
                                // Show computed styles
                                if (Object.keys(styles.computed).length > 0) {
                                    console.log("    Key Computed Styles:");
                                    for (const [prop, value] of Object.entries(styles.computed)) {
                                        console.log(`      ${prop}: ${value}`);
                                    }
                                }
                            } else {
                                console.log("  Note: No significant CSS styles found for this shadow DOM element");
                            }
                            
                        } catch (jsError) {
                            if (debug) {
                                console.log(`    JavaScript CSS extraction failed: ${jsError.message}`);
                            }
                            console.log("  Note: CSS styles not available (element may be in shadow DOM)");
                        }
                    } else {
                        console.log("  Error getting declared styles");
                    }
                }
            }

            if (showComputed) {
                try {
                    const { computedStyle } = await CSS.getComputedStyleForNode({ nodeId: nodeId });
                    const relevantStyles = {};
                    
                    // Filter to show only meaningful computed styles
                    const importantProps = [
                        'display', 'position', 'width', 'height', 'margin', 'padding', 
                        'border', 'background', 'background-color', 'color', 'font-size', 'font-family',
                        'z-index', 'opacity', 'visibility', 'overflow', 'float', 'clear', 'top', 'left', 'right', 'bottom'
                    ];
                    
                    for (const prop of computedStyle) {
                        if (importantProps.includes(prop.name) && 
                            prop.value && 
                            prop.value !== 'auto' && 
                            prop.value !== 'normal' && 
                            prop.value !== 'initial' &&
                            prop.value !== 'rgba(0, 0, 0, 0)' &&
                            prop.value !== '0px') {
                            relevantStyles[prop.name] = prop.value;
                        }
                    }
                    
                    if (Object.keys(relevantStyles).length > 0) {
                        console.log(`${indent}  Key computed styles:`);
                        for (const [prop, value] of Object.entries(relevantStyles)) {
                            console.log(`${indent}    ${prop}: ${value}`);
                        }
                    } else {
                        console.log(`${indent}  No significant computed styles`);
                    }
                } catch (error) {
                    if (debug) {
                        console.log(`    Computed styles error: ${error.message}`);
                    }
                    // Check if this might be a shadow DOM element
                    if (error.message.includes("Could not find node") || nodeId === 0) {
                        console.log(`${indent}  Note: Computed styles not available (element may be in shadow DOM)`);
                    } else {
                        console.log(`${indent}  Error getting computed styles`);
                    }
                }
            }
            } catch (error) {
                if (debug) {
                    console.log(`    DOM querySelector error for element: ${error.message}`);
                }
                console.log(`  Error finding element in DOM: ${elementInfo.selector || elementInfo.tag}`);
            }
        }
    }

        client.close();
    } catch (error) {
        console.error('Error connecting to Chrome:', error.message);
        console.error('\nMake sure Chrome is running with remote debugging enabled:');
        console.error('/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome --remote-debugging-port=9222');
        process.exit(1);
    }
})();